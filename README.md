# Implementation of Search and Shortest Path Algorithms

For this project, it was necessary to implement more than 10 known search algorithms with the intention of comparison. It is known that every one of them are selected depending on the type of task or data wanted. In this case, we used 3 different structures to supply enough data for the algorithms to work properly. These are the structures:

+ Weighted Graph
+ 8-Puzzle
+ Tic-Tac-Toe

This next image shows the ideal weighted graph that contains 26 nodes with letters (alphabet). Every time you run this specific cell named ``` VISUAL PRESENTATION OF THE WEIGHTED GRAPH, WITH SPECIFICATIONS ```, you can obtain a different organization of the graph with its nodes. This image is an example:

<img width="1260" height="1098" alt="download" src="https://github.com/user-attachments/assets/9ca58279-567a-4ffa-b770-ad3f56c19f96" />

##
The algorithms for this general implementation are shortly explained before the code cell with its title, easier to understand for everyone ðŸ˜€. This is the complete list:

1. Breadth-First Search (BFS)
2. Depth-First Search (DFS)
3. Uniform-Cost Search (UCS)
4. Depth-Limited Search (DLS)
5. Iterative Deepening Depth-First Search (IDDFS)
6. Bidirectional Search
7. A* (A-star) Search
8. IDA* Search
9. Pruning: Implement a search algorithm (like Minimax or Î±âˆ’Î²) and demonstrate the pruning technique to reduce the search space.
10. Dijkstra's Algorithm
11. Floyd-Warshall Algorithm

Have in mind that some of them were separated by groups to be tested on the 3 data structures selected. Everything is explain in the .ipynb file ðŸ˜€


